\documentclass[conference,compsoc,final,a4paper]{IEEEtran}
\usepackage[utf8]{inputenx}

%% Bitte legen Sie hier den Titel und den Autor der Arbeit fest
\newcommand{\autorA}[0]{Büchner, Jannis}
\newcommand{\autorB}[0]{Büchner, Niklas}
\newcommand{\autorC}[0]{Vierling, Jörg}
\newcommand{\dokumententitel}[0]{Tik-Tak-Toe Roboter}

\input{preambel} % Weitere Einstellungen aus einer anderen Datei lesen

\begin{document}

% Titel des Dokuments
\title{\dokumententitel}

% Namen der Autoren
\author{
  \IEEEauthorblockN{
    \autorA\\
    \autorB\\
    \autorC
  }
  \IEEEauthorblockA{
    Hochschule Mannheim\\
    Fakultät für Informatik\\
    Paul-Wittsack-Str. 10,
    68163 Mannheim
    }
}

% Titel erzeugen
\maketitle
\thispagestyle{plain}
\pagestyle{plain}

% Eigentliches Dokument beginnt hier
% ----------------------------------------------------------------------------------------------------------

% Kurze Zusammenfassung des Dokuments
\begin{abstract}

Das Spiel Tik-Tak-Toe kann über einen selbstgebauten Plotter mit Hilfe eines ESP32-WROOM als autonomer Roboter umgesetzt werden, welcher selbstständig gegen einen menschlichen Spieler antretten kann. Dies umfasst die vollständige Darstellung des Spielfelds, die Züge und das Zeichen einer Gewinnlinie, welche der Roboter ohne fremde Steuerung ausführen kann. Der Roboter übernimmt sowohl die Aufgabe des Spielführer als auch die des Gegenspielers.

Das Spiel wird auf einem Blatt Papier über den dreiachsigen Roboter gezeichnet. Alle Spielzüge eines menschlichen Spielers werden über eine Tastatur eingegeben und vom Roboter im Spielfeld markiert. Für den Zug des Roboters wird über einen Algorithmus das beste Feld ausgewählt und gezogen. Sobald ein Gewinner feststeht, wird die Gewinnlinie im Spielfeld eingezeichnet und ein neues Spiel ermöglicht.

\end{abstract}

% Inhaltsverzeichnis erzeugen
{\small\tableofcontents}

\section{Projektziel}

Ziel dieses Projektes war es einen kleinen Roboter zu entwickeln, der Tik-Tak-Toe
auf einem Blatt Papier gegen den Nutzer spielen kann. Hierbei wurde Tik-Tak-Toe
gewählt, da es ein simples aber sehr bekanntes Spiel ist.

Das Team hat sich gegen die Nutzung eines schon existierenden Roboters oder Roboter-Kit
entschieden, um mit allen Bereichen der Robotik in Kontakt zu kommen. Ziel war es hier
eine Fachschafts übergreifende Kooperation zu nutzen, um einen optimalen Wissenstransfer
zu erreichen.

Um das Spiel Tik-Tak-Toe spielen zu können soll der Roboter in der Lage sein das Spielfeld
sowie die Züge aller Spieler zu zeichen. Daraus ergab sich die grundsätzlichen Anforderung
an die Hardware, dass sie eine Bewegung in alle drei Raumrichtungen unabhängig voneinander
ermöglichen muss. Zudem sollte diese robust gestaltet und einfach zu realisieren sein.
Deswegen wurde entschieden einen Plotter zu bauen anstelle eines komplizierteren
Roboterarms. Dies hatte vor allem den Vorteil, dass die Bewegungen einfach zu realisieren
sind, ohne komplizierte Koordinatentransformationen durchführen zu müssen.


\section{Mechanik}

\subsection{Allgemeiner Aufbau}

Da zu Beginn des Projekts kein Roboter vorhanden war, musste nicht nur der Code geschrieben, sondern auch die Hardware
konstruiert werden. Die grundsätzlichen Anforderungen an die Hardware waren, dass sie eine Bewegung in alle drei Raumrichtungen
unabhängig voneinander ermöglichen muss, robust gestaltet und einfach zu realisieren sein sollte. Deswegen wurde entschieden einen
Plotter zu bauen anstelle eines komplizierteren Roboterarms. Dies hatte vor allem den Vorteil, dass die Bewegungen einfach zu
realisieren sind, ohne komplizierte Koordinatentransformationen durchführen zu müssen.

Um den Plotter zu bauen wurde Fischertechnik eingesetzt. Zum einen waren davon schon Teile vorhanden, zum anderen erfüllen diese
Materialien die Anforderungen an Robustheit ausreichend. Des Weiteren lass sich lineare Bewegungen mithilfe von Spindelgetrieben
oder Kegelzahnräder einfach realisieren lassen.

Die Spindelgetriebe haben den Vorteil, dass sie aus einzelnen Schneckenteilen bestehen, die nacheinander auf eine Achse geschoben
werden und dadurch in verschiedenen Längen konstruiert werden können. Damit die Schneckenteile nicht verrutschen befinden sich an
den Enden klemmbare Schnecken, die mithilfe von Spannzangen fixiert werden. Letztlich befindet sich an jeder Achse noch ein Zahnrad,
das zum Antrieb des Spindelgetriebe genutzt wird.

Die Bewegungen in x, y und z-Richtung werden separat voneinander gesteuert. Im Prinzip ist der Plotter somit aus drei Schichten
aufgebaut. Die unterste Schicht, der Grundrahmen, ist für die Bewegung in x-Richtung, also vor und zurück, zuständig. Darauf
sitzen zwei y-Schlitten, die die mittlere Schicht darstellen. Diese sorgt für die Bewegung nach links und rechts, in y-Richtung.
Darauf sitzt der Stiftehalter, der in z-Richtung nach oben und unten bewegt werden kann.

Der Grundrahmen besteht aus jeweils einer Achse und einem Spindelgetriebe, die sich links und rechts am Plotter befinden und an
den Enden auf zwei Basisplatten befestigt sind. Auf jedem Paar aus Achse und Spindelgetriebe befindet sich ein y-Schlitten, welcher
durch die Drehbewegung des Spindelgetriebes nach vorne und hinten bewegt wird. Die Aufgabe der Achsen ist die Lasten und Momente
aufzunehmen. Ein Aufbau aus nur einem Spindelgetriebe und zwei Achsen hätte zur Folge, dass entweder das zu kompensierende Drehmoment
sehr groß gewesen wäre, wenn beide Achsen auf derselben Seite des Plotters angebracht worden wären oder die zwei Schlitten, sich nicht
gleichmäßig bewegt hätten, sondern verzogen hätten, wären die Achsen auf unterschiedlichen Seiten des Plotters angebracht worden.
Eine zweite Achse musste aber unbedingt eingebaut werden, weil sonst das Getriebe das Drehmoment kompensieren müsste, wofür es aber
nicht geeignet ist.

\subsection{X-Achse}

Damit sich die Spindelgetriebe der X-Achse gleich schnell und gleichzeitig drehen, sind diese mithilfe von einer Kette (bestehend aus einzelnen
Rastkettengliedern) verbunden. Dadurch wird eine gleichmäßige Bewegung gewährleistet und die Schlitten, die obendrauf sitzen,
verziehen sich nicht. Die Bewegung in x-Richtung wird durch einen XM-Motor von Fischertechnik ausgeführt, welcher auf einer
Basisplatte sitzt und eine der Getriebe mithilfe von Zahnrädern antreibt. Das Zahnrad an der Antriebswelle wurde so klein wie möglich
gewählt, im Vergleich zum Zahnrad an der Getriebewelle. Der Grund dafür ist, dass dadurch die Drehzahl reduziert wird, und die Schlitten
sich nicht zu schnell bewegen und dass das Drehmoment nochmal zusätzlich erhöht wird, um mechanische Ungenauigkeiten, die zu einem
größeren Widerstand führen, zu kompensieren. 

\begin{figure}[h]
\centering
\includegraphics[width=8.5cm]{../images/xAchse.png}
\caption{Antriebssystem der x-Achse (Ansicht von hinten)}
\label{Mechanik:Aufbau}
\end{figure}

\subsection{Y-Achse}

Die zwei y-Schlitten sind ebenfalls mit zwei Achsen und einem Spindelgetriebe verbunden. Auch hier nehmen die Achsen das Gewicht
sowie das resultierende Drehmoment des Stiftehalter auf. Im Gegensatz zum Aufbau in x-Richtung befinden sind diese übereinander angeordnet,
damit der Aufbau nicht zu sehr nach vorne ragt, sondern stattdessen in die Höhe. Der Nachteil dabei ist aber, dass sich der Stift nicht
zwischen den Achsen befindet, was zu einem exzentrischen Kraftfluss führt und somit ein größeres Drehmoment nach sich zieht. 
Der Motor (Motor XS von Fischertechnik), der die y-Bewegung ausführt, ist etwas leistungsschwacher als der für die x-Bewegung. Dies hat
den Vorteil, dass er sehr viel kleiner und leichter ist. Dadurch kann er direkt auf einem der zwei y-Schlitten angebracht werden, ohne
ein Ungleichgewicht zu erzeugen. Auch hier wird die Kraftübertragung zwischen der Antriebswelle des Motors und der Abtriebwelle des
Spindelgetriebes mithilfe von Zahnrädern ermöglicht. 

\begin{figure}[h]
\centering
\includegraphics[width=8.5cm]{../images/yAchse.png}
\caption{Antriebssystem der y-Achse (Ansicht von der Seite)}
\label{Mechanik:Aufbau}
\end{figure}

\subsection{Z-Achse}

Auf der y-Achse befindet sich ein weiterer Schlitten, welcher die Z-Achse darstellt und der im Großen und Ganzen aus zwei Teilen besteht. 
Der eine Teil ist für das Anheben und Absetzen des Stiftes zuständig. Dieser besteht aus einer Rastachse mit Schnecke, die über
Kegelzahnräder bewegt wird. Auf der Schnecke befindet sich eine Schneckenmutter, deren Drehbewegung verhindert wird, indem sie an einem
Klotz festgemacht ist, durch den eine parallele Achse geht. Dadurch werden die Mutter und der Klotz gezwungen sich nach oben und unten zu
bewegen. An dem Klotz befindet sich der Stiftehalter. Das Ziel bei der Konstruktion des Stiftehalter war, ein einfacher, effizienter und
effektiver Aufbau, mit dem der Stift sowohl angehoben als auch mit Druck abgesetzt werden kann. Des Weiteren sollte es möglich sein, viele
verschiedenen Arten von Stifte zum Spielen verwenden zu können. Die beste Lösung für dieses Problem war den Stift mithilfe von Tesa-Film
an zwei aneinander befestigte Bausteine zu kleben. 

Das Kegelzahnrad an der Schnecke wird durch einen XS Motor von Fischertechnik bewegt. Dieser befindet sich ebenfalls auf dem Schlitten.
Der zweite Teil des Schlittens besteht aus einer Konstruktion, die verhindern soll, dass der Stift sich zu sehr verbiegt. Die L-förmige
Konstruktion liegt von allen Seiten press am Stift und ist direkt mit dem Schlitten und den Achsen verbunden. Sie bewegt sich nicht mit
dem Stift nach oben und unten. Dass der Stift sich leicht verbiegt, lässt sich nicht verhindern aber dadurch stark einschränken.

\begin{figure}[h]
\centering
\includegraphics[width=8.5cm]{../images/zAchse.png}
\caption{Stifthalter}
\label{Mechanik:Aufbau}
\end{figure}

\section{Elektrik}
Der Aufbau der elektrischen Schaltung auf dem Stecksystem des ESP32-WROVER-Boards.

\subsection{Aufbau der Versuchsumgebung}
\begin{figure}[h]
\centering
\includegraphics[width=8.5cm]{../images/board.png}
\caption{Aufbau Entwicklungs-Board}
\label{Elektrik:DevBoard}
\end{figure}
\begin{figure}[h]
\centering
\includegraphics[width=8.5cm]{../images/board2.png}
\caption{Schaltung Entwicklungs-Board}
\label{Elektrik:DevBoardInternal}
\end{figure}

In den Abbildung 1 und 2 sind die einzelnen Leiterbahnen zu sehen, auf welchen die einzelnen Bauteile platziert werden können (grüne Linien). 
Dieser Aufbau ermöglicht bis zu 5 direkte Verbindungen innerhalb einer Leiterbahn und insgesamt 60 elektrisch voneinander getrennte Leitungen.

Die äußeren Leiterbahnen sind für die Spannungsversorgung vorgesehen und erstrecken sich über das gesamte Board. Diese Leiterbahnen werden mit 5 V bzw. 3,3 V betrieben.
Die Verbindungen zwischen dem Micro-Controller und dem Entwicklungsboard wird mithilfe eines Extension Boards hergestellt. Das Extension Board ist so konzipiert, 
dass die einzelnen Pins des Micro-Controllers mit bestimmten Leiterbahnen auf dem ESP32-WROVER-Boards verbunden werden.

Zu beachten ist hierbei das Insgesamt 40 Leiterbahnen somit nicht frei benutzt werden können, da diese eine direkte Verbindung mit Micro-Controller darstellen.
\begin{figure}[h]
\centering
\includegraphics[width=8.5cm]{../images/ext_board.png}
\caption{Schaltung Entwicklungs-Board}
\label{Elektrik:DevBoardInternal}
\end{figure}

Die durch die Platzierung des Extensions-Boards verwendeten Leiterbahnen sind für die aktuelle Schaltung unerheblich, da die verfügbaren Leiterbahnen ausreichend sind.

Der Vorteil dieser Vorgehensweise besteht darin, dass durch das Stecksystem keine permanente Verbindung erzeugt werden muss. 
Die daraus resultierende Flexibilität ermöglicht ein experimentelles Vorgehen und den Vergleich der potenziell verfügbaren Antriebsarten.

\subsection{Ansteuerung der Motoren}
Für die Umwandlung der elektrischen Signalen des Micro-Controllers in Bewegungen sind zwei verschiedene Motortypen untersucht worden.

\begin{itemize}
	\item Servo-Motor
	\item Gleichstrom-Elektromotor
\end{itemize}

\subsection{Gleichstrom-Elektromotoren}

Für die Gleichstrom-Elektromotoren werden Motoren aus dem Fischer Technik Sortiment verwendet. 
Diese Motoren sind aufgrund der Produkzugehörigkeit mit den passenden Aufnahmen versehen, um Kompatibilitätsprobleme mit der Mechanik auszuschließen.

\textit{’DC’ steht für direct current, zu Deutsch Gleichstrom und bedeutet, dass sich der Strom nicht über einen Zeitraum ändert. Bei einem DC-Motor oder im deutschen Gleichstrommotor handelt es sich um Elektromotoren, die im Wesentlichen aus
einer elektrischen eine mechanische Energie erzeugen." } \autocite{metzgerkonzepte}

Für die Verwendung innerhalb der Mechanik ist es erforderlich, dass der Motor in beide Richtungen drehen könnne und über ausreichendes Drehmoment bei der gegebenen Übersetzung verfügt.
Aufgrund der unterschiedlichen Anforderungen werden 2 unterschiedliche Motoren verwendet.
\begin{itemize}
\item Motor XM 9V
\item Motor XS 9V
\end{itemize}

Die Leistungsdaten des Motor sind wie folgt definiert.\footnote{Quelle: https://ftcommunity.de/knowhow/bauteildaten/motoren/ft135485_neu.pdf}

XM-Motor
Spannung: 9VDC. Bei maximaler Leistung, Drehzahl: 337 U/min, Stromaufnahme: 0,863 A, Drehmoment: 0,0587 Nm
XS-Motor (ToDo)
Spannung: 9VDC. Bei maximaler Leistung, Drehzahl: - U/min, Stromaufnahme: - A, Drehmoment: - Nm

Da beide Motoren mit jeweils 9V Gleichstrom (DC) betrieben werden, können sie nicht direkt über die Spannungsschiene des Micro-Controllers angesteuert werden, 
da diese maximal 5V liefert. Obwohl ein Betrieb mit 5V möglich wäre, würde dies zu einer Verringerung des Drehmoments führen. Um eine optimale Bewegung zu gewährleisten, 
wird eine 9V Stromversorgung angestrebt.  Eine Richtungsänderung der Motoren kann durch das Tauschen der anliegenden Spannung erreicht werden.  

\subsection{Motortreiber}

Für die Ansteuerung der Motoren über den Micro-Controller wird ein seperater Motortreiber, L293D, verwendet.
Dieser gehört zur Familie der IC Chips (Integrated Circuit Chip). Der Chip ermöglicht durch die Verwendung von 2 Kanälen die Drehrichtung 
sowie die Geschwindikeit des Motors per PWM zu steuern.

\begin{figure}[h]
  \centering
\includegraphics[width=8.5cm]{../images/L293D.png}
\caption{L293D Schaltplan}
\label{Elektrik:L293D}
\end{figure}

\subsection{Pulsweitenmodulation}

PWM (Pulsweitenmodulation) ermöglicht die präzise Steuerung der Drehgeschwindigkeit eines Motors. Dabei wird kein konstantes Signal an den Motor angelegt,
sondern das Signal periodisch zwischen den Zuständen "An" und "Aus" gewechselt. Die Drehgeschwindigkeit wird durch die Anpassung der Pulsweiten innerhalb der Perioden 
bestimmt \autocite{611797}. Aufgrund der hohen Frequenz wird ein konstante Drehbewegung erreicht. 

In der aktuellen Konfiguration werden jedoch nur zwei Geschwindigkeiten benötigt: Stillstand (0) und maximale Geschwindigkeit. 
Dies wird durch die entsprechende Taktfrequenz in der Software gesteuert und durch die Verbindung der 
spezifizierten Pins des Micro-Controllers mit Pin 2 des Treibers realisiert.

Die Ansteuerung des Motors über den Treiber wird mithilfe von Pin 1, Pin 2 und Pin 7 realisiert. 
Diese Pins werden mit Digitalsignalen vom Micro-Controller gesteuert.
\begin{itemize}
  \item Pin 1 ist für die generelle Aktivierung des Motors verantwortlich
  \item Pin 2 und Pin 7 steuern die jeweilige Drehrichtung des Motors
\end{itemize}

Die folgende Tabelle zeigt die Kombinationen der Zustände von Pin 1, Pin 2 und Pin 7 und die resultierende Motorbewegung:

\begin{table}[]
  \begin{tabular}{llll}
  \hline
  \textbf{Pin1} & \textbf{Pin2} & \textbf{Pin2} & \textbf{Motor Bewegung}         \\ \hline
  H             & H             & L             & Drehung im Uhrzeigersinn        \\
  H             & L             & H             & Drehung gegen den Uhrzeigersinn \\
  L             & X             & X             & Keine Drehung                   \\ \hline
  \end{tabular}
\end{table}

Hierbei steht "H" für den High-Zustand (1) und "L" für den Low-Zustand (0). Wenn Pin 1 auf Low (L) gesetzt wird, wird der Motor nicht gedreht.

\subsection{Achsenansteuerung}

Aufgurnd der höheren Gewichtslast und der Sicherstellung einer konstanten Geschiwndigkeit, werden die x und Y Achsen durch eine XM Motor betrieben.
Hierbei wird für jede Achse ein seperater Treiber benötigt.

Für die Z-Achse kann eine schwächere Variante des Motors verwendet werden, was wiedereum einen Treibe benötigen würde.

\subsection{Servo-Motor}

Als Alternative könnte ein Servo-Motor verwendet werden, der die Höhe der Z-Achse über einen Arm verändert. 
In diesem Fall könnte auf den Treiber verzichtet werden. Allerdings wäre die Systemkompatibilität mit der Mechanik aufgrund der Nicht-Fischertechnik-Teile nicht gegeben. 
Daher wurde trotz des zusätzlichen Treibers ein Fischertechnik DC Motor für die Z-Achse verwendet.

\subsection{Schaltplan}

Aufgrund der aufgeführten Anforderungen und Eigenschaft, ergibt sich folgender elektrischer Aufbau auf Basis des ESP32-WROVER-Boards.
\begin{center}
\includegraphics[width=8.5cm]{../images/schaltplan.png}
\caption{Schaltplan}
\label{Elektrik:Schaltplan}
\end{center}

\section{Softwaresteuerung}

\subsection{Steuerung}

Für die Steuerung des Roboter standen verschiedene Methoden zur Verfügung. Die einzige Anforderung dabei
war es dass die Steuerung in der Lage ist die einzelnen Motoren und weitere Hardware Komponenten
zu kontrollieren. Hierzu haben wir uns folgende Möglichkeiten überlegt:

\begin{itemize}
  \item Steuerung über einen externen Computer
  \item Steuerung über eine mobile App
  \item Steuerung über einen Prozessor mit eingebautem Code
\end{itemize}

Die Steuerung über einen externen Computer wurde als erste Lösung betrachtet. Der Vorteil
ist hier, dass man auch eine vollfunktionsfähigens Betriebssystem mitsamt allen dafür existierenden
Paketen und Programmiersprachen zurückgreifen kann. Da aber das vollständige Betriebssystem auch
dazuführt, dass Services gestartet werden, die mit der eigentlichen Aufgabe des Roboters nichts zu
tun haben, wurde sich gegen diesen Ansatz entschieden. Zusätzlich erzwingt eine solche Steuerung
eine dauerhafte Verbindung zu dem Computer. Dies ist nicht erwünschens wert, da der Roboter autonom
handlungsfähig sein soll.

Als zweite Wahl kam die Steuerung über eine mobile App ins Spiel. Dies ermöglicht es, dass die
eigentlichen Bewegungen auf einem Gerät mit viel Prozessorstärke ausgeführt werden kann und dann nur
noch an den Roboter übermittelt werden muss. Somit ist auch der Zweck des Roboters
durch die Veränderung des Programmcodes auf dem Smartphone anpassbar. Die Schwachstelle hier ist,
dass weiterhin ein eingebetteter Prozess in Roboter vorhanden sein muss, der eine stabile
Kommunikation mit dem Mobilegerät besitzen muss. Während des Bau unseres Prototypen ist es den Autoren,
nicht gelungen eine stabile Kommunikation per Bluetooth mit einem iOS Gerät herzustellen.
Was die Nutzung des Roboters weiter einschränkt. Kommunikation per Wifi konnte hergestellt werden,
allerdings müssen sich sowohl das Mobiltelefon als auch der Roboter im 
selben Netzwerk befinden. Dies setzt eine Eingabemöglichkeit auf dem Roboter voraus oder dass
die Zugangsdaten vordefiniert sind. Beide Möglichkeiten sind in diesem Projekt nicht realisierbar,
da die Motorsteuerung schon alle Pins belegt und der während der Entwicklung und dem Einsatz in der
Hochschule in unterschiedlichen Netzwerken laufen können soll.

Letzlich fiel die Entscheidung darauf allen Code auf dem eingebetteten Chip zu spielen und dort
das gesamte Spiel zu implementieren. Dies bringt auch den Vorteil, dass der Roboter mit der Verbindung
zum Strom sofort spielbar ist. Außerdem werden so alle Fehlerfälle ausgeschlossen, die durch die
drahtlose Kommunikation zustande kommen könnten. Nachteilig ist hier, dass der Programmcode nur
vergleichsweise umständlich verändert werden kann. Da der Roboter nur für den aktuell singulären
Zweck des Tik-Tak-Toe spielen geschaffen wurde, wiegt dieser Nachteil allerdings nicht schwer.

\subsection{Tik-Tak-Toe Algorithmus}

Für den Tik-Tak-Toe Algorithmus wurde ein in C implementierter Algorithmus erstellt, der direkt auf
den ESP32-WROOM eingebettet wurde. Hierbei wurde großer Wert auf eine kompakte und einfache
Implementierung gelegt, da der gesamte Programmcode einschließlich des während der Laufzeit
gehaltenen Speichers in die 520KB Speicher des Chips passen mussten.

Um den Code einfach zu halten, wurde die Spielausführung auf einen der beiden CPU Kerne beschränkt.
Damit ist die Logik des Spiels einfach nachzuvollziehen, da sie von oben nach unten gelesen werden kann.
Um dieses Ziel zu erfüllen, wurden alle Bewegungen des Roboters als blockierende Calls im Programm
umgesetzt.

Kompakt wurde die Speichernutzung gehalten, indem das Spielfeld in zwei einzelne 16Bit Integer integriert wurde.
Da das Spielfeld nur 9 Felder hat, werden nur 9Bit pro Spieler benötigt, um zu speichern, ob der Spieler
auf dem jeweiligen Feld aktiv ist. Damit sind 16Bit Integer die kleinst mögliche Speichereinheit, in der
diese Daten für einen Spieler gespeichert werden kann. Alle möglichen Gewinnstellungen werden entsprechend
auch von einem einzelnen 16Bit Integer repräsentiert. Um herauszufinden, ob ein Spieler gewonnen hat, kann
nun die Gewinnposition per bitweisem UND mit dem Spielfeld vergleichen und wenn das Ergebnis der Operation
der Gewinnposition entspricht, hat der Spieler diese erreicht.

Bei einem Spiel zwischen Mensch und Maschine nutzt der Roboter die enthaltenen Gewinnpositionen als
Entscheidungsgrundlage für den nächsten Zug. Dabei wird geprüft, welche der Gewinnpositionen noch erreichbar
sind. Danach wird ermittelt, wie viele Züge dazu noch zu ziehen sind. Die Gewinnposition mit den
wenigsten Zügen wird versucht zu erreichen. Falls mehrere Gewinnpositionen gleich gut gewichtet wurden
oder noch kein Zug gespielt wurde, wird zufällig eine Zielposition ausgewählt. Die Berechnung läuft
dabei nach jedem Zug, wodurch der Roboter auf den Zug seines Gegners reagieren kann.

\subsection{Abstraktion Hardware und Software}

Um den Autoren die Möglichkeit zu geben, zu unterschiedlichen Zeitpunkten an dem Roboter arbeiten
zu können, wurde die Software und die Hardwareentwicklung per Abstraktionsstufe getrennt. Hierbei wurde
ein mindestmaß an Funktionalitäten definiert, die der Roboter bereitstellen können muss, um Tik-Tak-Toe
ausführen zu können. Diese Funktionalität wurde dann als Schnittstelle zwischen der Hardware und Software
genutzt. Damit wurde eine unabhängige Entwicklung der Softwarefunktionalität von der Hardware geschaffen.

Die Hardware Funktionen haben hierbei keinerlei Wissen und Verantwortung über den aktuellen Spielstand.
Wählt ein Spieler einen Zug aus, der nicht mehr spielbar ist, so erkennt die Spielelogik das und führt
entsprechend die entsprechende Bewebungsfunktion aus, um dies zu kommunizieren. Dies sorgt für eine
optimale Abstraktion und Testbarkeit der Software.

Die Schnittstelle lässt sich in 4 Teile unterteilen.

\begin{verbatim}
void waitUntilGameStarts();
int getFieldSelectedByPlayer();
\end{verbatim}

Der oben aufgeführten erste Teil beinhaltet Funktionen, deren Aufgabe alle Nutzereingaben abdecken.
Ihre Aufgabe ist es so lange die weitere Ausführung des Programms zu blockieren,
bis ein Spiel gestartet werden kann oder bis der Nutzer ein Feld gewählt hat.

Beide Funktionen bauen dabei auf der Tastatur auf. Ein Spieler zeigt an, dass er ein Spiel starten
möchte, indem er die Taste \enquote{1} für ein Spiel gegen den Roboter oder die Taste \enquote{2}
für ein Spiel zwischen zwei Menschen auswählt. Zur Selektion eines Spielzuges stellt die Tastatur
das Spielfeld dar. Dabei entspricht jede nummerische Taste einem Feld im Spielfeld. So kann
gewählt werden, welcher Spielzug der Spieler als nächstes spielen möchte.

In diesen Funktionen wurden später auch die Möglichkeit eingebaut, alle Achsen des Roboters von 
Hand zu steuern, um ihn richtig ausrichten zu können. Dies ermöglicht es, dass hardware-nahe Funktionen
nicht im Spielalgorithmus verankert werden müssen und dennoch gut eingebaut werden konnten.

\begin{verbatim}
void moveRobotArmToOrigin();
void moveRobotArmToFieldOne();
void moveRobotArmToFieldTwo();
void moveRobotArmToFieldThree();
void moveRobotArmToFieldFour();
void moveRobotArmToFieldFive();
void moveRobotArmToFieldSix();
void moveRobotArmToFieldSeven();
void moveRobotArmToFieldEight();
void moveRobotArmToFieldNine();
\end{verbatim}

Im aufgeführten zweiten Teil, sind alle Funktionen beinhaltet, die Bewegungen des Roboter darstellen. Diese haben
zum einen den Zweck zu einem bestimmten Spielfeld und wieder zurück zu kommen. Zu beachten ist hier,
dass die Hardware den aktuellen Ort des Stiftes kennen muss, um diesen nach dem entsprechenden Funktionsaufruf
wieder zurück zum Ausgangspunkt navigieren zu können.

Zur Navigation des Robots wird auf allen Achsen auf Zeitangaben gesetzt, in denen die Motoren aktiviert werden. Die
aktuelle Position des Roboters wird daher als Zeit der aktivierten Motoren gespeichert. Die zugrundeliegende Annahme
ist, dass sich ein Motor in beide Richtungen gleich schnell dreht. Die größe des impliziten Koordinatensystems wird
daher durch die Größe des Spielfelds festgesetzt. Dies beträgt 6 Sekunden, was bei den Motoren ca. 8cm entspricht.

Dies ist der dritte Teil:

\begin{verbatim}
void drawCross();
void drawCircle();
void drawHorizontalWinningLine();
void drawVerticalWinningLine();
void drawTopToBottomWinningLine();
void drawBottomToTopWinningLine();
\end{verbatim}

Der dritte Teil der Schnittstelle beschäftigt sich mit den Zeichenanweisungen des Roboters. Hierbei legt der
Tik-Tak-Toe Algorithmus fest, was gezeichnet werden soll. Die exakten Details der Bewegung und wann der Stift
auf das Blatt abgesetzt und gehoben werden muss, wurden auch hier als hardware-spezifisch deklariert.

Der Roboter zeichnet ein Kreuz, wie in Tik-Tak-Toe üblich, ersetzt aber den Kreis durch ein Viereck. Dies ist
der einfacheren Ansteuerung der Motoren bei geraden Linie geschuldet. Um einen Kreis zu zeichen, muss die
Geschwindigkeit des Motors sowohl auf X als auch auf Y Achse in kurzen Intervallen angepasst werden. Einen 
guten Kreis zu erhalten wurde hierbei als zu aufwändig eingestuft und der Fokus eher auf das Spielverhalten
des Roboters gelegt wurde.

\begin{verbatim}
void showCannotPlayMove();
\end{verbatim}

Zu letzt benötigt der Roboter eine Möglichkeit zu kommunizieren, dass ein Spielzug nicht gespielt werden kann,
weil dieser schon von einem anderen Spieler zuvor gespielt wurde. Dies stellt den vierten und letzten Teil der
Schnittstelle dar.

Die Aufteilung der Schnittstelle ermöglicht dabei nicht nur die getrennte Entwicklung von Hardware und Software,
sondern auch, dass die Software extern und automatisiert getestet werden konnte. Damit wurde die Funktionalität des Algorithmus
sichergestellt und erlaubte eine Test-basierte-Entwicklung auf einem leistungsstarken Computer ohne direkten
Hardwarezugriff zu benötigen.

\section{Fazit und Ausblick}

\subsection{Offene Probleme}

Auf mechanischer Ebene besitzt der Roboter viel Spiel, was die exakte Steuerung schwierig macht. Ein Problem mit der Anordnung
des Motors und des kleinen Zahnrades ist, dass die
Antriebswelle nicht fixiert werden kann und sich erstmal schräg stellt, bevor das große Zahnrad anfängt sich zu drehen. Jegliche
Idee die Welle zu fixieren hätte dazu geführt, dass die Konstruktion an der Kette reibt. Um dieses Problem zu lösen hätte es größere
Umbauten am gesamten Plotter benötigt, die aufgrund des späten Zeitpunktes, zu dem der Motor angekommen ist, nicht mehr möglich waren.

Auch die Stabilität anderer Bausteine verursachen Spiel im Roboter. So sorgt das Aufsetzen des Stiftes dafür, dass dessen Halterung
leicht vom Papier weggedrückt wird. Dies ist nötig, da der Stift mit etwas Druck auf dem Papier aufgesetzt werden muss, um
Tinte zu hinterlassen. Zwar konnte der benötigte Druck durch Einsatz eines Filsstifts statt eines Kugelschreibers reduziert werden,
allerdings wird weiterhin etwas Druck benötigt, was die Halterung anhebt.

Ein ähnliches Problem besitzt auch die Y-Achse welche sich leicht zusammenzieht, wenn der Schlitten an das Ende der Achse ankommt.

Einen zusätzlichen Verbesserungspunkt stellen die Motoren dar, da sie nicht in beide Richtungen exakt gleich schnell drehen. Eine
mögliche Lösung sind hier Endschalter, die aktiviert werden, sobald der Roboter das Ende der jeweiligen Achse erreicht. Diese wurden
auf Grund an mangelnder Anzahl an Pins am Chip und späten Auftretens im Projekt nicht genutzt.

\subsection{Positive Aspekte}

Als ein positiver Aspekt stellte sich der verwendete ESP32-WROOM heraus. Der Chip erlaubt dem Roboter nicht nur ohne externe Steuerung
auszukommen, sondern bietet mehr Leistung als der Roboter benötigt. Ein Großteil des Spiels besteht aus Warten auf die Motoren und die
Spiellogik ist nicht sehr leistungshungrig, sodass noch mehr Funktionlitäten mit dem Roboter abgebildete werden könnten.

Auch die Nutzung von Fischertechnik brachte sehr viele Vorteile. So konnte sehr schnell über die Mechanik des Roboters iteriert werden,
was eine hohe Entwicklungsgeschwindigkeit ermöglichte. Zusätzlich dazu erlaubte das Steckkastensystem das Erkunden neuer Lösungsmöglichkeiten
inklusive einfacher Rückbauten im Falle eines nachteiligen Ergebnis. Auch die Kombination aus Plastik und Metal führt zu einer einfachen 
Anpassbarkeit mit gleichzeitig robustem Unterbau, um das Gewicht des Roboters optimal zu tragen. Nichtsdestotrotz lässt sich ein Teil des
Spiels auf die Bauteile zurückführen. Im gesamten Blick haben die Vorteile der schnellen Veränderung im Projekt allerdings überwogen.

Als letzten positiven Aspekt ist die Abstraktion der Software und Hardware zu nennen. Dies ermöglichte einen testbasierten
Entwicklungsansatz, der keinen ESP32-WROOM voraussetzte, um ausgeführt zu werden. Zwar hatten alle Teammitglieder Zugriff auf entsprechende
Chips, aber diese hätten immer eine langsames Aufspielen vorausgesetzt, was die Entwicklung verlangsamt hätte. Auch konnten so mehrere
Teammitglieder parallen und unabhängig von einander sowohl an der Software als auch an der Hardware iterieren. Gleichzeitig war die
Integration der beiden Systeme sehr einfach möglich und kann daher nur empfohlen werden.

\subsection{Ausblick}

Der aktuelle Roboter ist eine gute Grundlage für alle Arten an Aktivitäten, die etwas mit Zeichnen zu tun haben. Wenn die Präzision
gesteigert werden kann, können auch Spiele implementiert werden, die mit kleineren Feldern auskommen müssen. Die könnte beispielsweise
4-Gewinnt ermöglichen.

Auch der generellen Verwendung des Roboters als Plotter steht nichts im Weg. Zwar sind aktuell nur gerade Linien implementiert, aber
auch Kurven können mit der aktuelen Motorensteuerung umgesetzt werden, was dem Roboter ermöglicht beliebige Bilder zu zeichnen.

% Literaturverzeichnis
\addcontentsline{toc}{section}{Literatur}
\printbibliography

\end{document}
